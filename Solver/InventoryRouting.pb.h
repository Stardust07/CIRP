// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: InventoryRouting.proto

#ifndef PROTOBUF_INCLUDED_InventoryRouting_2eproto
#define PROTOBUF_INCLUDED_InventoryRouting_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_InventoryRouting_2eproto 

namespace protobuf_InventoryRouting_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[9];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_InventoryRouting_2eproto
namespace pb {
class Delivery;
class DeliveryDefaultTypeInternal;
extern DeliveryDefaultTypeInternal _Delivery_default_instance_;
class InventoryRouting;
class InventoryRoutingDefaultTypeInternal;
extern InventoryRoutingDefaultTypeInternal _InventoryRouting_default_instance_;
class InventoryRouting_Input;
class InventoryRouting_InputDefaultTypeInternal;
extern InventoryRouting_InputDefaultTypeInternal _InventoryRouting_Input_default_instance_;
class InventoryRouting_Output;
class InventoryRouting_OutputDefaultTypeInternal;
extern InventoryRouting_OutputDefaultTypeInternal _InventoryRouting_Output_default_instance_;
class Node;
class NodeDefaultTypeInternal;
extern NodeDefaultTypeInternal _Node_default_instance_;
class Route;
class RouteDefaultTypeInternal;
extern RouteDefaultTypeInternal _Route_default_instance_;
class RoutesInPeriod;
class RoutesInPeriodDefaultTypeInternal;
extern RoutesInPeriodDefaultTypeInternal _RoutesInPeriod_default_instance_;
class Submission;
class SubmissionDefaultTypeInternal;
extern SubmissionDefaultTypeInternal _Submission_default_instance_;
class Vehicle;
class VehicleDefaultTypeInternal;
extern VehicleDefaultTypeInternal _Vehicle_default_instance_;
}  // namespace pb
namespace google {
namespace protobuf {
template<> ::pb::Delivery* Arena::CreateMaybeMessage<::pb::Delivery>(Arena*);
template<> ::pb::InventoryRouting* Arena::CreateMaybeMessage<::pb::InventoryRouting>(Arena*);
template<> ::pb::InventoryRouting_Input* Arena::CreateMaybeMessage<::pb::InventoryRouting_Input>(Arena*);
template<> ::pb::InventoryRouting_Output* Arena::CreateMaybeMessage<::pb::InventoryRouting_Output>(Arena*);
template<> ::pb::Node* Arena::CreateMaybeMessage<::pb::Node>(Arena*);
template<> ::pb::Route* Arena::CreateMaybeMessage<::pb::Route>(Arena*);
template<> ::pb::RoutesInPeriod* Arena::CreateMaybeMessage<::pb::RoutesInPeriod>(Arena*);
template<> ::pb::Submission* Arena::CreateMaybeMessage<::pb::Submission>(Arena*);
template<> ::pb::Vehicle* Arena::CreateMaybeMessage<::pb::Vehicle>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace pb {

// ===================================================================

class InventoryRouting_Input : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb.InventoryRouting.Input) */ {
 public:
  InventoryRouting_Input();
  virtual ~InventoryRouting_Input();

  InventoryRouting_Input(const InventoryRouting_Input& from);

  inline InventoryRouting_Input& operator=(const InventoryRouting_Input& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InventoryRouting_Input(InventoryRouting_Input&& from) noexcept
    : InventoryRouting_Input() {
    *this = ::std::move(from);
  }

  inline InventoryRouting_Input& operator=(InventoryRouting_Input&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const InventoryRouting_Input& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InventoryRouting_Input* internal_default_instance() {
    return reinterpret_cast<const InventoryRouting_Input*>(
               &_InventoryRouting_Input_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(InventoryRouting_Input* other);
  friend void swap(InventoryRouting_Input& a, InventoryRouting_Input& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InventoryRouting_Input* New() const final {
    return CreateMaybeMessage<InventoryRouting_Input>(NULL);
  }

  InventoryRouting_Input* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<InventoryRouting_Input>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const InventoryRouting_Input& from);
  void MergeFrom(const InventoryRouting_Input& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InventoryRouting_Input* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pb.Vehicle vehicles = 2;
  int vehicles_size() const;
  void clear_vehicles();
  static const int kVehiclesFieldNumber = 2;
  ::pb::Vehicle* mutable_vehicles(int index);
  ::google::protobuf::RepeatedPtrField< ::pb::Vehicle >*
      mutable_vehicles();
  const ::pb::Vehicle& vehicles(int index) const;
  ::pb::Vehicle* add_vehicles();
  const ::google::protobuf::RepeatedPtrField< ::pb::Vehicle >&
      vehicles() const;

  // repeated .pb.Node nodes = 3;
  int nodes_size() const;
  void clear_nodes();
  static const int kNodesFieldNumber = 3;
  ::pb::Node* mutable_nodes(int index);
  ::google::protobuf::RepeatedPtrField< ::pb::Node >*
      mutable_nodes();
  const ::pb::Node& nodes(int index) const;
  ::pb::Node* add_nodes();
  const ::google::protobuf::RepeatedPtrField< ::pb::Node >&
      nodes() const;

  // double bestObj = 4;
  void clear_bestobj();
  static const int kBestObjFieldNumber = 4;
  double bestobj() const;
  void set_bestobj(double value);

  // double referenceObj = 5;
  void clear_referenceobj();
  static const int kReferenceObjFieldNumber = 5;
  double referenceobj() const;
  void set_referenceobj(double value);

  // double referenceTime = 6;
  void clear_referencetime();
  static const int kReferenceTimeFieldNumber = 6;
  double referencetime() const;
  void set_referencetime(double value);

  // int32 periodNum = 1;
  void clear_periodnum();
  static const int kPeriodNumFieldNumber = 1;
  ::google::protobuf::int32 periodnum() const;
  void set_periodnum(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.InventoryRouting.Input)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::pb::Vehicle > vehicles_;
  ::google::protobuf::RepeatedPtrField< ::pb::Node > nodes_;
  double bestobj_;
  double referenceobj_;
  double referencetime_;
  ::google::protobuf::int32 periodnum_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_InventoryRouting_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class InventoryRouting_Output : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb.InventoryRouting.Output) */ {
 public:
  InventoryRouting_Output();
  virtual ~InventoryRouting_Output();

  InventoryRouting_Output(const InventoryRouting_Output& from);

  inline InventoryRouting_Output& operator=(const InventoryRouting_Output& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InventoryRouting_Output(InventoryRouting_Output&& from) noexcept
    : InventoryRouting_Output() {
    *this = ::std::move(from);
  }

  inline InventoryRouting_Output& operator=(InventoryRouting_Output&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const InventoryRouting_Output& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InventoryRouting_Output* internal_default_instance() {
    return reinterpret_cast<const InventoryRouting_Output*>(
               &_InventoryRouting_Output_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(InventoryRouting_Output* other);
  friend void swap(InventoryRouting_Output& a, InventoryRouting_Output& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InventoryRouting_Output* New() const final {
    return CreateMaybeMessage<InventoryRouting_Output>(NULL);
  }

  InventoryRouting_Output* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<InventoryRouting_Output>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const InventoryRouting_Output& from);
  void MergeFrom(const InventoryRouting_Output& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InventoryRouting_Output* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pb.RoutesInPeriod allRoutes = 1;
  int allroutes_size() const;
  void clear_allroutes();
  static const int kAllRoutesFieldNumber = 1;
  ::pb::RoutesInPeriod* mutable_allroutes(int index);
  ::google::protobuf::RepeatedPtrField< ::pb::RoutesInPeriod >*
      mutable_allroutes();
  const ::pb::RoutesInPeriod& allroutes(int index) const;
  ::pb::RoutesInPeriod* add_allroutes();
  const ::google::protobuf::RepeatedPtrField< ::pb::RoutesInPeriod >&
      allroutes() const;

  // @@protoc_insertion_point(class_scope:pb.InventoryRouting.Output)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::pb::RoutesInPeriod > allroutes_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_InventoryRouting_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class InventoryRouting : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb.InventoryRouting) */ {
 public:
  InventoryRouting();
  virtual ~InventoryRouting();

  InventoryRouting(const InventoryRouting& from);

  inline InventoryRouting& operator=(const InventoryRouting& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InventoryRouting(InventoryRouting&& from) noexcept
    : InventoryRouting() {
    *this = ::std::move(from);
  }

  inline InventoryRouting& operator=(InventoryRouting&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const InventoryRouting& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InventoryRouting* internal_default_instance() {
    return reinterpret_cast<const InventoryRouting*>(
               &_InventoryRouting_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(InventoryRouting* other);
  friend void swap(InventoryRouting& a, InventoryRouting& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InventoryRouting* New() const final {
    return CreateMaybeMessage<InventoryRouting>(NULL);
  }

  InventoryRouting* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<InventoryRouting>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const InventoryRouting& from);
  void MergeFrom(const InventoryRouting& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InventoryRouting* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef InventoryRouting_Input Input;
  typedef InventoryRouting_Output Output;

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:pb.InventoryRouting)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_InventoryRouting_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Node : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb.Node) */ {
 public:
  Node();
  virtual ~Node();

  Node(const Node& from);

  inline Node& operator=(const Node& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Node(Node&& from) noexcept
    : Node() {
    *this = ::std::move(from);
  }

  inline Node& operator=(Node&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Node& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Node* internal_default_instance() {
    return reinterpret_cast<const Node*>(
               &_Node_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Node* other);
  friend void swap(Node& a, Node& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Node* New() const final {
    return CreateMaybeMessage<Node>(NULL);
  }

  Node* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Node>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Node& from);
  void MergeFrom(const Node& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Node* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double x = 2;
  void clear_x();
  static const int kXFieldNumber = 2;
  double x() const;
  void set_x(double value);

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // int32 initQuantity = 4;
  void clear_initquantity();
  static const int kInitQuantityFieldNumber = 4;
  ::google::protobuf::int32 initquantity() const;
  void set_initquantity(::google::protobuf::int32 value);

  // double y = 3;
  void clear_y();
  static const int kYFieldNumber = 3;
  double y() const;
  void set_y(double value);

  // int32 capacity = 5;
  void clear_capacity();
  static const int kCapacityFieldNumber = 5;
  ::google::protobuf::int32 capacity() const;
  void set_capacity(::google::protobuf::int32 value);

  // int32 minLevel = 6;
  void clear_minlevel();
  static const int kMinLevelFieldNumber = 6;
  ::google::protobuf::int32 minlevel() const;
  void set_minlevel(::google::protobuf::int32 value);

  // double holidingCost = 8;
  void clear_holidingcost();
  static const int kHolidingCostFieldNumber = 8;
  double holidingcost() const;
  void set_holidingcost(double value);

  // int32 unitDemand = 7;
  void clear_unitdemand();
  static const int kUnitDemandFieldNumber = 7;
  ::google::protobuf::int32 unitdemand() const;
  void set_unitdemand(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.Node)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double x_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 initquantity_;
  double y_;
  ::google::protobuf::int32 capacity_;
  ::google::protobuf::int32 minlevel_;
  double holidingcost_;
  ::google::protobuf::int32 unitdemand_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_InventoryRouting_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Vehicle : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb.Vehicle) */ {
 public:
  Vehicle();
  virtual ~Vehicle();

  Vehicle(const Vehicle& from);

  inline Vehicle& operator=(const Vehicle& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Vehicle(Vehicle&& from) noexcept
    : Vehicle() {
    *this = ::std::move(from);
  }

  inline Vehicle& operator=(Vehicle&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Vehicle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vehicle* internal_default_instance() {
    return reinterpret_cast<const Vehicle*>(
               &_Vehicle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Vehicle* other);
  friend void swap(Vehicle& a, Vehicle& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Vehicle* New() const final {
    return CreateMaybeMessage<Vehicle>(NULL);
  }

  Vehicle* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Vehicle>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Vehicle& from);
  void MergeFrom(const Vehicle& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vehicle* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // int32 capacity = 2;
  void clear_capacity();
  static const int kCapacityFieldNumber = 2;
  ::google::protobuf::int32 capacity() const;
  void set_capacity(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.Vehicle)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 capacity_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_InventoryRouting_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Route : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb.Route) */ {
 public:
  Route();
  virtual ~Route();

  Route(const Route& from);

  inline Route& operator=(const Route& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Route(Route&& from) noexcept
    : Route() {
    *this = ::std::move(from);
  }

  inline Route& operator=(Route&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Route& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Route* internal_default_instance() {
    return reinterpret_cast<const Route*>(
               &_Route_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Route* other);
  friend void swap(Route& a, Route& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Route* New() const final {
    return CreateMaybeMessage<Route>(NULL);
  }

  Route* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Route>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Route& from);
  void MergeFrom(const Route& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Route* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pb.Delivery deliveries = 2;
  int deliveries_size() const;
  void clear_deliveries();
  static const int kDeliveriesFieldNumber = 2;
  ::pb::Delivery* mutable_deliveries(int index);
  ::google::protobuf::RepeatedPtrField< ::pb::Delivery >*
      mutable_deliveries();
  const ::pb::Delivery& deliveries(int index) const;
  ::pb::Delivery* add_deliveries();
  const ::google::protobuf::RepeatedPtrField< ::pb::Delivery >&
      deliveries() const;

  // @@protoc_insertion_point(class_scope:pb.Route)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::pb::Delivery > deliveries_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_InventoryRouting_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RoutesInPeriod : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb.RoutesInPeriod) */ {
 public:
  RoutesInPeriod();
  virtual ~RoutesInPeriod();

  RoutesInPeriod(const RoutesInPeriod& from);

  inline RoutesInPeriod& operator=(const RoutesInPeriod& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RoutesInPeriod(RoutesInPeriod&& from) noexcept
    : RoutesInPeriod() {
    *this = ::std::move(from);
  }

  inline RoutesInPeriod& operator=(RoutesInPeriod&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RoutesInPeriod& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoutesInPeriod* internal_default_instance() {
    return reinterpret_cast<const RoutesInPeriod*>(
               &_RoutesInPeriod_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(RoutesInPeriod* other);
  friend void swap(RoutesInPeriod& a, RoutesInPeriod& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RoutesInPeriod* New() const final {
    return CreateMaybeMessage<RoutesInPeriod>(NULL);
  }

  RoutesInPeriod* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RoutesInPeriod>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RoutesInPeriod& from);
  void MergeFrom(const RoutesInPeriod& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoutesInPeriod* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pb.Route routes = 1;
  int routes_size() const;
  void clear_routes();
  static const int kRoutesFieldNumber = 1;
  ::pb::Route* mutable_routes(int index);
  ::google::protobuf::RepeatedPtrField< ::pb::Route >*
      mutable_routes();
  const ::pb::Route& routes(int index) const;
  ::pb::Route* add_routes();
  const ::google::protobuf::RepeatedPtrField< ::pb::Route >&
      routes() const;

  // @@protoc_insertion_point(class_scope:pb.RoutesInPeriod)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::pb::Route > routes_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_InventoryRouting_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Delivery : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb.Delivery) */ {
 public:
  Delivery();
  virtual ~Delivery();

  Delivery(const Delivery& from);

  inline Delivery& operator=(const Delivery& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Delivery(Delivery&& from) noexcept
    : Delivery() {
    *this = ::std::move(from);
  }

  inline Delivery& operator=(Delivery&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Delivery& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Delivery* internal_default_instance() {
    return reinterpret_cast<const Delivery*>(
               &_Delivery_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(Delivery* other);
  friend void swap(Delivery& a, Delivery& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Delivery* New() const final {
    return CreateMaybeMessage<Delivery>(NULL);
  }

  Delivery* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Delivery>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Delivery& from);
  void MergeFrom(const Delivery& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Delivery* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 node = 1;
  void clear_node();
  static const int kNodeFieldNumber = 1;
  ::google::protobuf::int32 node() const;
  void set_node(::google::protobuf::int32 value);

  // int32 quantity = 2;
  void clear_quantity();
  static const int kQuantityFieldNumber = 2;
  ::google::protobuf::int32 quantity() const;
  void set_quantity(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.Delivery)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 node_;
  ::google::protobuf::int32 quantity_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_InventoryRouting_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Submission : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb.Submission) */ {
 public:
  Submission();
  virtual ~Submission();

  Submission(const Submission& from);

  inline Submission& operator=(const Submission& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Submission(Submission&& from) noexcept
    : Submission() {
    *this = ::std::move(from);
  }

  inline Submission& operator=(Submission&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Submission& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Submission* internal_default_instance() {
    return reinterpret_cast<const Submission*>(
               &_Submission_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(Submission* other);
  friend void swap(Submission& a, Submission& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Submission* New() const final {
    return CreateMaybeMessage<Submission>(NULL);
  }

  Submission* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Submission>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Submission& from);
  void MergeFrom(const Submission& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Submission* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string author = 1;
  void clear_author();
  static const int kAuthorFieldNumber = 1;
  const ::std::string& author() const;
  void set_author(const ::std::string& value);
  #if LANG_CXX11
  void set_author(::std::string&& value);
  #endif
  void set_author(const char* value);
  void set_author(const char* value, size_t size);
  ::std::string* mutable_author();
  ::std::string* release_author();
  void set_allocated_author(::std::string* author);

  // string algorithm = 2;
  void clear_algorithm();
  static const int kAlgorithmFieldNumber = 2;
  const ::std::string& algorithm() const;
  void set_algorithm(const ::std::string& value);
  #if LANG_CXX11
  void set_algorithm(::std::string&& value);
  #endif
  void set_algorithm(const char* value);
  void set_algorithm(const char* value, size_t size);
  ::std::string* mutable_algorithm();
  ::std::string* release_algorithm();
  void set_allocated_algorithm(::std::string* algorithm);

  // string thread = 3;
  void clear_thread();
  static const int kThreadFieldNumber = 3;
  const ::std::string& thread() const;
  void set_thread(const ::std::string& value);
  #if LANG_CXX11
  void set_thread(::std::string&& value);
  #endif
  void set_thread(const char* value);
  void set_thread(const char* value, size_t size);
  ::std::string* mutable_thread();
  ::std::string* release_thread();
  void set_allocated_thread(::std::string* thread);

  // string cpu = 4;
  void clear_cpu();
  static const int kCpuFieldNumber = 4;
  const ::std::string& cpu() const;
  void set_cpu(const ::std::string& value);
  #if LANG_CXX11
  void set_cpu(::std::string&& value);
  #endif
  void set_cpu(const char* value);
  void set_cpu(const char* value, size_t size);
  ::std::string* mutable_cpu();
  ::std::string* release_cpu();
  void set_allocated_cpu(::std::string* cpu);

  // string ram = 5;
  void clear_ram();
  static const int kRamFieldNumber = 5;
  const ::std::string& ram() const;
  void set_ram(const ::std::string& value);
  #if LANG_CXX11
  void set_ram(::std::string&& value);
  #endif
  void set_ram(const char* value);
  void set_ram(const char* value, size_t size);
  ::std::string* mutable_ram();
  ::std::string* release_ram();
  void set_allocated_ram(::std::string* ram);

  // string language = 6;
  void clear_language();
  static const int kLanguageFieldNumber = 6;
  const ::std::string& language() const;
  void set_language(const ::std::string& value);
  #if LANG_CXX11
  void set_language(::std::string&& value);
  #endif
  void set_language(const char* value);
  void set_language(const char* value, size_t size);
  ::std::string* mutable_language();
  ::std::string* release_language();
  void set_allocated_language(::std::string* language);

  // string compiler = 7;
  void clear_compiler();
  static const int kCompilerFieldNumber = 7;
  const ::std::string& compiler() const;
  void set_compiler(const ::std::string& value);
  #if LANG_CXX11
  void set_compiler(::std::string&& value);
  #endif
  void set_compiler(const char* value);
  void set_compiler(const char* value, size_t size);
  ::std::string* mutable_compiler();
  ::std::string* release_compiler();
  void set_allocated_compiler(::std::string* compiler);

  // string os = 8;
  void clear_os();
  static const int kOsFieldNumber = 8;
  const ::std::string& os() const;
  void set_os(const ::std::string& value);
  #if LANG_CXX11
  void set_os(::std::string&& value);
  #endif
  void set_os(const char* value);
  void set_os(const char* value, size_t size);
  ::std::string* mutable_os();
  ::std::string* release_os();
  void set_allocated_os(::std::string* os);

  // string problem = 21;
  void clear_problem();
  static const int kProblemFieldNumber = 21;
  const ::std::string& problem() const;
  void set_problem(const ::std::string& value);
  #if LANG_CXX11
  void set_problem(::std::string&& value);
  #endif
  void set_problem(const char* value);
  void set_problem(const char* value, size_t size);
  ::std::string* mutable_problem();
  ::std::string* release_problem();
  void set_allocated_problem(::std::string* problem);

  // string instance = 22;
  void clear_instance();
  static const int kInstanceFieldNumber = 22;
  const ::std::string& instance() const;
  void set_instance(const ::std::string& value);
  #if LANG_CXX11
  void set_instance(::std::string&& value);
  #endif
  void set_instance(const char* value);
  void set_instance(const char* value, size_t size);
  ::std::string* mutable_instance();
  ::std::string* release_instance();
  void set_allocated_instance(::std::string* instance);

  // string duration = 23;
  void clear_duration();
  static const int kDurationFieldNumber = 23;
  const ::std::string& duration() const;
  void set_duration(const ::std::string& value);
  #if LANG_CXX11
  void set_duration(::std::string&& value);
  #endif
  void set_duration(const char* value);
  void set_duration(const char* value, size_t size);
  ::std::string* mutable_duration();
  ::std::string* release_duration();
  void set_allocated_duration(::std::string* duration);

  // string email = 32;
  void clear_email();
  static const int kEmailFieldNumber = 32;
  const ::std::string& email() const;
  void set_email(const ::std::string& value);
  #if LANG_CXX11
  void set_email(::std::string&& value);
  #endif
  void set_email(const char* value);
  void set_email(const char* value, size_t size);
  ::std::string* mutable_email();
  ::std::string* release_email();
  void set_allocated_email(::std::string* email);

  // string date = 33;
  void clear_date();
  static const int kDateFieldNumber = 33;
  const ::std::string& date() const;
  void set_date(const ::std::string& value);
  #if LANG_CXX11
  void set_date(::std::string&& value);
  #endif
  void set_date(const char* value);
  void set_date(const char* value, size_t size);
  ::std::string* mutable_date();
  ::std::string* release_date();
  void set_allocated_date(::std::string* date);

  // double obj = 31;
  void clear_obj();
  static const int kObjFieldNumber = 31;
  double obj() const;
  void set_obj(double value);

  // @@protoc_insertion_point(class_scope:pb.Submission)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr author_;
  ::google::protobuf::internal::ArenaStringPtr algorithm_;
  ::google::protobuf::internal::ArenaStringPtr thread_;
  ::google::protobuf::internal::ArenaStringPtr cpu_;
  ::google::protobuf::internal::ArenaStringPtr ram_;
  ::google::protobuf::internal::ArenaStringPtr language_;
  ::google::protobuf::internal::ArenaStringPtr compiler_;
  ::google::protobuf::internal::ArenaStringPtr os_;
  ::google::protobuf::internal::ArenaStringPtr problem_;
  ::google::protobuf::internal::ArenaStringPtr instance_;
  ::google::protobuf::internal::ArenaStringPtr duration_;
  ::google::protobuf::internal::ArenaStringPtr email_;
  ::google::protobuf::internal::ArenaStringPtr date_;
  double obj_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_InventoryRouting_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// InventoryRouting_Input

// int32 periodNum = 1;
inline void InventoryRouting_Input::clear_periodnum() {
  periodnum_ = 0;
}
inline ::google::protobuf::int32 InventoryRouting_Input::periodnum() const {
  // @@protoc_insertion_point(field_get:pb.InventoryRouting.Input.periodNum)
  return periodnum_;
}
inline void InventoryRouting_Input::set_periodnum(::google::protobuf::int32 value) {
  
  periodnum_ = value;
  // @@protoc_insertion_point(field_set:pb.InventoryRouting.Input.periodNum)
}

// repeated .pb.Vehicle vehicles = 2;
inline int InventoryRouting_Input::vehicles_size() const {
  return vehicles_.size();
}
inline void InventoryRouting_Input::clear_vehicles() {
  vehicles_.Clear();
}
inline ::pb::Vehicle* InventoryRouting_Input::mutable_vehicles(int index) {
  // @@protoc_insertion_point(field_mutable:pb.InventoryRouting.Input.vehicles)
  return vehicles_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::pb::Vehicle >*
InventoryRouting_Input::mutable_vehicles() {
  // @@protoc_insertion_point(field_mutable_list:pb.InventoryRouting.Input.vehicles)
  return &vehicles_;
}
inline const ::pb::Vehicle& InventoryRouting_Input::vehicles(int index) const {
  // @@protoc_insertion_point(field_get:pb.InventoryRouting.Input.vehicles)
  return vehicles_.Get(index);
}
inline ::pb::Vehicle* InventoryRouting_Input::add_vehicles() {
  // @@protoc_insertion_point(field_add:pb.InventoryRouting.Input.vehicles)
  return vehicles_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::Vehicle >&
InventoryRouting_Input::vehicles() const {
  // @@protoc_insertion_point(field_list:pb.InventoryRouting.Input.vehicles)
  return vehicles_;
}

// repeated .pb.Node nodes = 3;
inline int InventoryRouting_Input::nodes_size() const {
  return nodes_.size();
}
inline void InventoryRouting_Input::clear_nodes() {
  nodes_.Clear();
}
inline ::pb::Node* InventoryRouting_Input::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:pb.InventoryRouting.Input.nodes)
  return nodes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::pb::Node >*
InventoryRouting_Input::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:pb.InventoryRouting.Input.nodes)
  return &nodes_;
}
inline const ::pb::Node& InventoryRouting_Input::nodes(int index) const {
  // @@protoc_insertion_point(field_get:pb.InventoryRouting.Input.nodes)
  return nodes_.Get(index);
}
inline ::pb::Node* InventoryRouting_Input::add_nodes() {
  // @@protoc_insertion_point(field_add:pb.InventoryRouting.Input.nodes)
  return nodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::Node >&
InventoryRouting_Input::nodes() const {
  // @@protoc_insertion_point(field_list:pb.InventoryRouting.Input.nodes)
  return nodes_;
}

// double bestObj = 4;
inline void InventoryRouting_Input::clear_bestobj() {
  bestobj_ = 0;
}
inline double InventoryRouting_Input::bestobj() const {
  // @@protoc_insertion_point(field_get:pb.InventoryRouting.Input.bestObj)
  return bestobj_;
}
inline void InventoryRouting_Input::set_bestobj(double value) {
  
  bestobj_ = value;
  // @@protoc_insertion_point(field_set:pb.InventoryRouting.Input.bestObj)
}

// double referenceObj = 5;
inline void InventoryRouting_Input::clear_referenceobj() {
  referenceobj_ = 0;
}
inline double InventoryRouting_Input::referenceobj() const {
  // @@protoc_insertion_point(field_get:pb.InventoryRouting.Input.referenceObj)
  return referenceobj_;
}
inline void InventoryRouting_Input::set_referenceobj(double value) {
  
  referenceobj_ = value;
  // @@protoc_insertion_point(field_set:pb.InventoryRouting.Input.referenceObj)
}

// double referenceTime = 6;
inline void InventoryRouting_Input::clear_referencetime() {
  referencetime_ = 0;
}
inline double InventoryRouting_Input::referencetime() const {
  // @@protoc_insertion_point(field_get:pb.InventoryRouting.Input.referenceTime)
  return referencetime_;
}
inline void InventoryRouting_Input::set_referencetime(double value) {
  
  referencetime_ = value;
  // @@protoc_insertion_point(field_set:pb.InventoryRouting.Input.referenceTime)
}

// -------------------------------------------------------------------

// InventoryRouting_Output

// repeated .pb.RoutesInPeriod allRoutes = 1;
inline int InventoryRouting_Output::allroutes_size() const {
  return allroutes_.size();
}
inline void InventoryRouting_Output::clear_allroutes() {
  allroutes_.Clear();
}
inline ::pb::RoutesInPeriod* InventoryRouting_Output::mutable_allroutes(int index) {
  // @@protoc_insertion_point(field_mutable:pb.InventoryRouting.Output.allRoutes)
  return allroutes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::pb::RoutesInPeriod >*
InventoryRouting_Output::mutable_allroutes() {
  // @@protoc_insertion_point(field_mutable_list:pb.InventoryRouting.Output.allRoutes)
  return &allroutes_;
}
inline const ::pb::RoutesInPeriod& InventoryRouting_Output::allroutes(int index) const {
  // @@protoc_insertion_point(field_get:pb.InventoryRouting.Output.allRoutes)
  return allroutes_.Get(index);
}
inline ::pb::RoutesInPeriod* InventoryRouting_Output::add_allroutes() {
  // @@protoc_insertion_point(field_add:pb.InventoryRouting.Output.allRoutes)
  return allroutes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::RoutesInPeriod >&
InventoryRouting_Output::allroutes() const {
  // @@protoc_insertion_point(field_list:pb.InventoryRouting.Output.allRoutes)
  return allroutes_;
}

// -------------------------------------------------------------------

// InventoryRouting

// -------------------------------------------------------------------

// Node

// int32 id = 1;
inline void Node::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 Node::id() const {
  // @@protoc_insertion_point(field_get:pb.Node.id)
  return id_;
}
inline void Node::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:pb.Node.id)
}

// double x = 2;
inline void Node::clear_x() {
  x_ = 0;
}
inline double Node::x() const {
  // @@protoc_insertion_point(field_get:pb.Node.x)
  return x_;
}
inline void Node::set_x(double value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:pb.Node.x)
}

// double y = 3;
inline void Node::clear_y() {
  y_ = 0;
}
inline double Node::y() const {
  // @@protoc_insertion_point(field_get:pb.Node.y)
  return y_;
}
inline void Node::set_y(double value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:pb.Node.y)
}

// int32 initQuantity = 4;
inline void Node::clear_initquantity() {
  initquantity_ = 0;
}
inline ::google::protobuf::int32 Node::initquantity() const {
  // @@protoc_insertion_point(field_get:pb.Node.initQuantity)
  return initquantity_;
}
inline void Node::set_initquantity(::google::protobuf::int32 value) {
  
  initquantity_ = value;
  // @@protoc_insertion_point(field_set:pb.Node.initQuantity)
}

// int32 capacity = 5;
inline void Node::clear_capacity() {
  capacity_ = 0;
}
inline ::google::protobuf::int32 Node::capacity() const {
  // @@protoc_insertion_point(field_get:pb.Node.capacity)
  return capacity_;
}
inline void Node::set_capacity(::google::protobuf::int32 value) {
  
  capacity_ = value;
  // @@protoc_insertion_point(field_set:pb.Node.capacity)
}

// int32 minLevel = 6;
inline void Node::clear_minlevel() {
  minlevel_ = 0;
}
inline ::google::protobuf::int32 Node::minlevel() const {
  // @@protoc_insertion_point(field_get:pb.Node.minLevel)
  return minlevel_;
}
inline void Node::set_minlevel(::google::protobuf::int32 value) {
  
  minlevel_ = value;
  // @@protoc_insertion_point(field_set:pb.Node.minLevel)
}

// int32 unitDemand = 7;
inline void Node::clear_unitdemand() {
  unitdemand_ = 0;
}
inline ::google::protobuf::int32 Node::unitdemand() const {
  // @@protoc_insertion_point(field_get:pb.Node.unitDemand)
  return unitdemand_;
}
inline void Node::set_unitdemand(::google::protobuf::int32 value) {
  
  unitdemand_ = value;
  // @@protoc_insertion_point(field_set:pb.Node.unitDemand)
}

// double holidingCost = 8;
inline void Node::clear_holidingcost() {
  holidingcost_ = 0;
}
inline double Node::holidingcost() const {
  // @@protoc_insertion_point(field_get:pb.Node.holidingCost)
  return holidingcost_;
}
inline void Node::set_holidingcost(double value) {
  
  holidingcost_ = value;
  // @@protoc_insertion_point(field_set:pb.Node.holidingCost)
}

// -------------------------------------------------------------------

// Vehicle

// int32 id = 1;
inline void Vehicle::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 Vehicle::id() const {
  // @@protoc_insertion_point(field_get:pb.Vehicle.id)
  return id_;
}
inline void Vehicle::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:pb.Vehicle.id)
}

// int32 capacity = 2;
inline void Vehicle::clear_capacity() {
  capacity_ = 0;
}
inline ::google::protobuf::int32 Vehicle::capacity() const {
  // @@protoc_insertion_point(field_get:pb.Vehicle.capacity)
  return capacity_;
}
inline void Vehicle::set_capacity(::google::protobuf::int32 value) {
  
  capacity_ = value;
  // @@protoc_insertion_point(field_set:pb.Vehicle.capacity)
}

// -------------------------------------------------------------------

// Route

// repeated .pb.Delivery deliveries = 2;
inline int Route::deliveries_size() const {
  return deliveries_.size();
}
inline void Route::clear_deliveries() {
  deliveries_.Clear();
}
inline ::pb::Delivery* Route::mutable_deliveries(int index) {
  // @@protoc_insertion_point(field_mutable:pb.Route.deliveries)
  return deliveries_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::pb::Delivery >*
Route::mutable_deliveries() {
  // @@protoc_insertion_point(field_mutable_list:pb.Route.deliveries)
  return &deliveries_;
}
inline const ::pb::Delivery& Route::deliveries(int index) const {
  // @@protoc_insertion_point(field_get:pb.Route.deliveries)
  return deliveries_.Get(index);
}
inline ::pb::Delivery* Route::add_deliveries() {
  // @@protoc_insertion_point(field_add:pb.Route.deliveries)
  return deliveries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::Delivery >&
Route::deliveries() const {
  // @@protoc_insertion_point(field_list:pb.Route.deliveries)
  return deliveries_;
}

// -------------------------------------------------------------------

// RoutesInPeriod

// repeated .pb.Route routes = 1;
inline int RoutesInPeriod::routes_size() const {
  return routes_.size();
}
inline void RoutesInPeriod::clear_routes() {
  routes_.Clear();
}
inline ::pb::Route* RoutesInPeriod::mutable_routes(int index) {
  // @@protoc_insertion_point(field_mutable:pb.RoutesInPeriod.routes)
  return routes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::pb::Route >*
RoutesInPeriod::mutable_routes() {
  // @@protoc_insertion_point(field_mutable_list:pb.RoutesInPeriod.routes)
  return &routes_;
}
inline const ::pb::Route& RoutesInPeriod::routes(int index) const {
  // @@protoc_insertion_point(field_get:pb.RoutesInPeriod.routes)
  return routes_.Get(index);
}
inline ::pb::Route* RoutesInPeriod::add_routes() {
  // @@protoc_insertion_point(field_add:pb.RoutesInPeriod.routes)
  return routes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::Route >&
RoutesInPeriod::routes() const {
  // @@protoc_insertion_point(field_list:pb.RoutesInPeriod.routes)
  return routes_;
}

// -------------------------------------------------------------------

// Delivery

// int32 node = 1;
inline void Delivery::clear_node() {
  node_ = 0;
}
inline ::google::protobuf::int32 Delivery::node() const {
  // @@protoc_insertion_point(field_get:pb.Delivery.node)
  return node_;
}
inline void Delivery::set_node(::google::protobuf::int32 value) {
  
  node_ = value;
  // @@protoc_insertion_point(field_set:pb.Delivery.node)
}

// int32 quantity = 2;
inline void Delivery::clear_quantity() {
  quantity_ = 0;
}
inline ::google::protobuf::int32 Delivery::quantity() const {
  // @@protoc_insertion_point(field_get:pb.Delivery.quantity)
  return quantity_;
}
inline void Delivery::set_quantity(::google::protobuf::int32 value) {
  
  quantity_ = value;
  // @@protoc_insertion_point(field_set:pb.Delivery.quantity)
}

// -------------------------------------------------------------------

// Submission

// string author = 1;
inline void Submission::clear_author() {
  author_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Submission::author() const {
  // @@protoc_insertion_point(field_get:pb.Submission.author)
  return author_.GetNoArena();
}
inline void Submission::set_author(const ::std::string& value) {
  
  author_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.Submission.author)
}
#if LANG_CXX11
inline void Submission::set_author(::std::string&& value) {
  
  author_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.Submission.author)
}
#endif
inline void Submission::set_author(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  author_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.Submission.author)
}
inline void Submission::set_author(const char* value, size_t size) {
  
  author_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.Submission.author)
}
inline ::std::string* Submission::mutable_author() {
  
  // @@protoc_insertion_point(field_mutable:pb.Submission.author)
  return author_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Submission::release_author() {
  // @@protoc_insertion_point(field_release:pb.Submission.author)
  
  return author_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Submission::set_allocated_author(::std::string* author) {
  if (author != NULL) {
    
  } else {
    
  }
  author_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), author);
  // @@protoc_insertion_point(field_set_allocated:pb.Submission.author)
}

// string algorithm = 2;
inline void Submission::clear_algorithm() {
  algorithm_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Submission::algorithm() const {
  // @@protoc_insertion_point(field_get:pb.Submission.algorithm)
  return algorithm_.GetNoArena();
}
inline void Submission::set_algorithm(const ::std::string& value) {
  
  algorithm_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.Submission.algorithm)
}
#if LANG_CXX11
inline void Submission::set_algorithm(::std::string&& value) {
  
  algorithm_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.Submission.algorithm)
}
#endif
inline void Submission::set_algorithm(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  algorithm_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.Submission.algorithm)
}
inline void Submission::set_algorithm(const char* value, size_t size) {
  
  algorithm_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.Submission.algorithm)
}
inline ::std::string* Submission::mutable_algorithm() {
  
  // @@protoc_insertion_point(field_mutable:pb.Submission.algorithm)
  return algorithm_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Submission::release_algorithm() {
  // @@protoc_insertion_point(field_release:pb.Submission.algorithm)
  
  return algorithm_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Submission::set_allocated_algorithm(::std::string* algorithm) {
  if (algorithm != NULL) {
    
  } else {
    
  }
  algorithm_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), algorithm);
  // @@protoc_insertion_point(field_set_allocated:pb.Submission.algorithm)
}

// string thread = 3;
inline void Submission::clear_thread() {
  thread_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Submission::thread() const {
  // @@protoc_insertion_point(field_get:pb.Submission.thread)
  return thread_.GetNoArena();
}
inline void Submission::set_thread(const ::std::string& value) {
  
  thread_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.Submission.thread)
}
#if LANG_CXX11
inline void Submission::set_thread(::std::string&& value) {
  
  thread_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.Submission.thread)
}
#endif
inline void Submission::set_thread(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  thread_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.Submission.thread)
}
inline void Submission::set_thread(const char* value, size_t size) {
  
  thread_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.Submission.thread)
}
inline ::std::string* Submission::mutable_thread() {
  
  // @@protoc_insertion_point(field_mutable:pb.Submission.thread)
  return thread_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Submission::release_thread() {
  // @@protoc_insertion_point(field_release:pb.Submission.thread)
  
  return thread_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Submission::set_allocated_thread(::std::string* thread) {
  if (thread != NULL) {
    
  } else {
    
  }
  thread_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), thread);
  // @@protoc_insertion_point(field_set_allocated:pb.Submission.thread)
}

// string cpu = 4;
inline void Submission::clear_cpu() {
  cpu_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Submission::cpu() const {
  // @@protoc_insertion_point(field_get:pb.Submission.cpu)
  return cpu_.GetNoArena();
}
inline void Submission::set_cpu(const ::std::string& value) {
  
  cpu_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.Submission.cpu)
}
#if LANG_CXX11
inline void Submission::set_cpu(::std::string&& value) {
  
  cpu_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.Submission.cpu)
}
#endif
inline void Submission::set_cpu(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  cpu_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.Submission.cpu)
}
inline void Submission::set_cpu(const char* value, size_t size) {
  
  cpu_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.Submission.cpu)
}
inline ::std::string* Submission::mutable_cpu() {
  
  // @@protoc_insertion_point(field_mutable:pb.Submission.cpu)
  return cpu_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Submission::release_cpu() {
  // @@protoc_insertion_point(field_release:pb.Submission.cpu)
  
  return cpu_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Submission::set_allocated_cpu(::std::string* cpu) {
  if (cpu != NULL) {
    
  } else {
    
  }
  cpu_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cpu);
  // @@protoc_insertion_point(field_set_allocated:pb.Submission.cpu)
}

// string ram = 5;
inline void Submission::clear_ram() {
  ram_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Submission::ram() const {
  // @@protoc_insertion_point(field_get:pb.Submission.ram)
  return ram_.GetNoArena();
}
inline void Submission::set_ram(const ::std::string& value) {
  
  ram_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.Submission.ram)
}
#if LANG_CXX11
inline void Submission::set_ram(::std::string&& value) {
  
  ram_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.Submission.ram)
}
#endif
inline void Submission::set_ram(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  ram_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.Submission.ram)
}
inline void Submission::set_ram(const char* value, size_t size) {
  
  ram_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.Submission.ram)
}
inline ::std::string* Submission::mutable_ram() {
  
  // @@protoc_insertion_point(field_mutable:pb.Submission.ram)
  return ram_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Submission::release_ram() {
  // @@protoc_insertion_point(field_release:pb.Submission.ram)
  
  return ram_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Submission::set_allocated_ram(::std::string* ram) {
  if (ram != NULL) {
    
  } else {
    
  }
  ram_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ram);
  // @@protoc_insertion_point(field_set_allocated:pb.Submission.ram)
}

// string language = 6;
inline void Submission::clear_language() {
  language_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Submission::language() const {
  // @@protoc_insertion_point(field_get:pb.Submission.language)
  return language_.GetNoArena();
}
inline void Submission::set_language(const ::std::string& value) {
  
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.Submission.language)
}
#if LANG_CXX11
inline void Submission::set_language(::std::string&& value) {
  
  language_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.Submission.language)
}
#endif
inline void Submission::set_language(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.Submission.language)
}
inline void Submission::set_language(const char* value, size_t size) {
  
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.Submission.language)
}
inline ::std::string* Submission::mutable_language() {
  
  // @@protoc_insertion_point(field_mutable:pb.Submission.language)
  return language_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Submission::release_language() {
  // @@protoc_insertion_point(field_release:pb.Submission.language)
  
  return language_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Submission::set_allocated_language(::std::string* language) {
  if (language != NULL) {
    
  } else {
    
  }
  language_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), language);
  // @@protoc_insertion_point(field_set_allocated:pb.Submission.language)
}

// string compiler = 7;
inline void Submission::clear_compiler() {
  compiler_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Submission::compiler() const {
  // @@protoc_insertion_point(field_get:pb.Submission.compiler)
  return compiler_.GetNoArena();
}
inline void Submission::set_compiler(const ::std::string& value) {
  
  compiler_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.Submission.compiler)
}
#if LANG_CXX11
inline void Submission::set_compiler(::std::string&& value) {
  
  compiler_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.Submission.compiler)
}
#endif
inline void Submission::set_compiler(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  compiler_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.Submission.compiler)
}
inline void Submission::set_compiler(const char* value, size_t size) {
  
  compiler_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.Submission.compiler)
}
inline ::std::string* Submission::mutable_compiler() {
  
  // @@protoc_insertion_point(field_mutable:pb.Submission.compiler)
  return compiler_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Submission::release_compiler() {
  // @@protoc_insertion_point(field_release:pb.Submission.compiler)
  
  return compiler_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Submission::set_allocated_compiler(::std::string* compiler) {
  if (compiler != NULL) {
    
  } else {
    
  }
  compiler_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), compiler);
  // @@protoc_insertion_point(field_set_allocated:pb.Submission.compiler)
}

// string os = 8;
inline void Submission::clear_os() {
  os_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Submission::os() const {
  // @@protoc_insertion_point(field_get:pb.Submission.os)
  return os_.GetNoArena();
}
inline void Submission::set_os(const ::std::string& value) {
  
  os_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.Submission.os)
}
#if LANG_CXX11
inline void Submission::set_os(::std::string&& value) {
  
  os_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.Submission.os)
}
#endif
inline void Submission::set_os(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  os_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.Submission.os)
}
inline void Submission::set_os(const char* value, size_t size) {
  
  os_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.Submission.os)
}
inline ::std::string* Submission::mutable_os() {
  
  // @@protoc_insertion_point(field_mutable:pb.Submission.os)
  return os_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Submission::release_os() {
  // @@protoc_insertion_point(field_release:pb.Submission.os)
  
  return os_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Submission::set_allocated_os(::std::string* os) {
  if (os != NULL) {
    
  } else {
    
  }
  os_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), os);
  // @@protoc_insertion_point(field_set_allocated:pb.Submission.os)
}

// string problem = 21;
inline void Submission::clear_problem() {
  problem_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Submission::problem() const {
  // @@protoc_insertion_point(field_get:pb.Submission.problem)
  return problem_.GetNoArena();
}
inline void Submission::set_problem(const ::std::string& value) {
  
  problem_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.Submission.problem)
}
#if LANG_CXX11
inline void Submission::set_problem(::std::string&& value) {
  
  problem_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.Submission.problem)
}
#endif
inline void Submission::set_problem(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  problem_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.Submission.problem)
}
inline void Submission::set_problem(const char* value, size_t size) {
  
  problem_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.Submission.problem)
}
inline ::std::string* Submission::mutable_problem() {
  
  // @@protoc_insertion_point(field_mutable:pb.Submission.problem)
  return problem_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Submission::release_problem() {
  // @@protoc_insertion_point(field_release:pb.Submission.problem)
  
  return problem_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Submission::set_allocated_problem(::std::string* problem) {
  if (problem != NULL) {
    
  } else {
    
  }
  problem_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), problem);
  // @@protoc_insertion_point(field_set_allocated:pb.Submission.problem)
}

// string instance = 22;
inline void Submission::clear_instance() {
  instance_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Submission::instance() const {
  // @@protoc_insertion_point(field_get:pb.Submission.instance)
  return instance_.GetNoArena();
}
inline void Submission::set_instance(const ::std::string& value) {
  
  instance_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.Submission.instance)
}
#if LANG_CXX11
inline void Submission::set_instance(::std::string&& value) {
  
  instance_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.Submission.instance)
}
#endif
inline void Submission::set_instance(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  instance_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.Submission.instance)
}
inline void Submission::set_instance(const char* value, size_t size) {
  
  instance_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.Submission.instance)
}
inline ::std::string* Submission::mutable_instance() {
  
  // @@protoc_insertion_point(field_mutable:pb.Submission.instance)
  return instance_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Submission::release_instance() {
  // @@protoc_insertion_point(field_release:pb.Submission.instance)
  
  return instance_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Submission::set_allocated_instance(::std::string* instance) {
  if (instance != NULL) {
    
  } else {
    
  }
  instance_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), instance);
  // @@protoc_insertion_point(field_set_allocated:pb.Submission.instance)
}

// string duration = 23;
inline void Submission::clear_duration() {
  duration_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Submission::duration() const {
  // @@protoc_insertion_point(field_get:pb.Submission.duration)
  return duration_.GetNoArena();
}
inline void Submission::set_duration(const ::std::string& value) {
  
  duration_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.Submission.duration)
}
#if LANG_CXX11
inline void Submission::set_duration(::std::string&& value) {
  
  duration_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.Submission.duration)
}
#endif
inline void Submission::set_duration(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  duration_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.Submission.duration)
}
inline void Submission::set_duration(const char* value, size_t size) {
  
  duration_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.Submission.duration)
}
inline ::std::string* Submission::mutable_duration() {
  
  // @@protoc_insertion_point(field_mutable:pb.Submission.duration)
  return duration_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Submission::release_duration() {
  // @@protoc_insertion_point(field_release:pb.Submission.duration)
  
  return duration_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Submission::set_allocated_duration(::std::string* duration) {
  if (duration != NULL) {
    
  } else {
    
  }
  duration_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), duration);
  // @@protoc_insertion_point(field_set_allocated:pb.Submission.duration)
}

// double obj = 31;
inline void Submission::clear_obj() {
  obj_ = 0;
}
inline double Submission::obj() const {
  // @@protoc_insertion_point(field_get:pb.Submission.obj)
  return obj_;
}
inline void Submission::set_obj(double value) {
  
  obj_ = value;
  // @@protoc_insertion_point(field_set:pb.Submission.obj)
}

// string email = 32;
inline void Submission::clear_email() {
  email_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Submission::email() const {
  // @@protoc_insertion_point(field_get:pb.Submission.email)
  return email_.GetNoArena();
}
inline void Submission::set_email(const ::std::string& value) {
  
  email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.Submission.email)
}
#if LANG_CXX11
inline void Submission::set_email(::std::string&& value) {
  
  email_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.Submission.email)
}
#endif
inline void Submission::set_email(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.Submission.email)
}
inline void Submission::set_email(const char* value, size_t size) {
  
  email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.Submission.email)
}
inline ::std::string* Submission::mutable_email() {
  
  // @@protoc_insertion_point(field_mutable:pb.Submission.email)
  return email_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Submission::release_email() {
  // @@protoc_insertion_point(field_release:pb.Submission.email)
  
  return email_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Submission::set_allocated_email(::std::string* email) {
  if (email != NULL) {
    
  } else {
    
  }
  email_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), email);
  // @@protoc_insertion_point(field_set_allocated:pb.Submission.email)
}

// string date = 33;
inline void Submission::clear_date() {
  date_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Submission::date() const {
  // @@protoc_insertion_point(field_get:pb.Submission.date)
  return date_.GetNoArena();
}
inline void Submission::set_date(const ::std::string& value) {
  
  date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.Submission.date)
}
#if LANG_CXX11
inline void Submission::set_date(::std::string&& value) {
  
  date_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.Submission.date)
}
#endif
inline void Submission::set_date(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.Submission.date)
}
inline void Submission::set_date(const char* value, size_t size) {
  
  date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.Submission.date)
}
inline ::std::string* Submission::mutable_date() {
  
  // @@protoc_insertion_point(field_mutable:pb.Submission.date)
  return date_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Submission::release_date() {
  // @@protoc_insertion_point(field_release:pb.Submission.date)
  
  return date_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Submission::set_allocated_date(::std::string* date) {
  if (date != NULL) {
    
  } else {
    
  }
  date_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), date);
  // @@protoc_insertion_point(field_set_allocated:pb.Submission.date)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_InventoryRouting_2eproto
